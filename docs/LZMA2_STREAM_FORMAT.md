# Формат потока LZMA2 (raw stream)

Этот документ описывает **raw-поток LZMA2** — последовательность чанков, которая используется как «внутренний» формат сжатых данных LZMA2.

* Это **не** контейнер `.xz` и **не** контейнер `.7z`.
* Это ровно тот байтовый поток, который контейнеры (или ваше приложение) могут хранить «как есть».

LZMA2 — это обёртка над **LZMA1** (range coder + LZ77-словарь). В отличие от «чистого» LZMA1, LZMA2 разбивает поток на чанки и умеет:

* вставлять **несжатые** (copy) чанки;
* выполнять **сброс словаря** (dictionary reset);
* выполнять **сброс состояния LZMA** (state reset);
* при необходимости передавать **параметры LZMA (lc/lp/pb)** внутри потока.

## Соглашения

* Все размеры в заголовках чанков записываются в **big-endian**.
* Во всех заголовках хранится значение **(Size − 1)**. То есть:

  *прочитали `X` → реальный размер `X + 1`*

## Общая структура потока

Поток — это последовательность чанков, завершающаяся **маркером конца**:

```
[LZMA2 chunk] [LZMA2 chunk] ... 00
```

Маркер конца потока — один байт:

* `00` — End Of Stream.

---

## 1) Copy chunk (несжатый чанк)

### Control byte

* `01` — Copy chunk + **reset dictionary**
* `02` — Copy chunk без reset dictionary

### Заголовок

После control byte идут **2 байта** длины (uncompressed size):

```
+--------+-----------------+
| ctrl   |  size (2 bytes) |
+--------+-----------------+
```

Где:

* `size = (b0 << 8) | b1` (big-endian)
* `uncompressedSize = size + 1`

Диапазон: `1 .. 65536`.

### Payload

Сразу после заголовка идут `uncompressedSize` байт «как есть», без сжатия.

*Если ctrl = `01`, то перед копированием чанк обнуляет позицию словаря (dictionary reset).* 

---

## 2) LZMA chunk (сжатый чанк)

### Control byte

Control byte для LZMA-чанка (как его генерирует LZMA SDK / 7-Zip) лежит в диапазоне `80..FF`.

Биты control byte:

```
  7 6 5 4 3 2 1 0
 +---+---+---------+
 | 1 | M |  USIZEhi |
 +---+---+---------+

M       = два бита (6..5) — режим/флаги ресетов
USIZEhi = пять бит (4..0) — старшие 5 бит (UnpackSize-1)
```

Режим `M`:

| M (bits6..5) | Диапазон control | Значение |
|---:|---:|---|
| 0 (`00`) | `80..9F` | продолжение: **без reset state**, **без новых props** |
| 1 (`01`) | `A0..BF` | **reset state**, props как раньше |
| 2 (`10`) | `C0..DF` | **reset state** + **новый байт props** |
| 3 (`11`) | `E0..FF` | **reset dictionary** + **reset state** + **новый байт props** |

Практически:

* первый LZMA-чанк потока обычно имеет `control >= E0` (полный reset + props);
* далее возможны чанки без ресетов (`80..9F`) или с reset state (`A0..BF`).

### Заголовок

После control byte идут:

```
+--------+-------------------+-------------------+-------------------+
| ctrl   | unpackSize-1 (2b)  |  packSize-1 (2b)  |  [props (1b)]     |
+--------+-------------------+-------------------+-------------------+
```

Где:

* `unpackSizeMinus1 = ((ctrl & 0x1F) << 16) | (u0 << 8) | u1`
* `unpackSize = unpackSizeMinus1 + 1`

Диапазон: `1 .. 2 MiB` (потому что 5 + 16 = 21 бит).

* `packSizeMinus1 = (p0 << 8) | p1`
* `packSize = packSizeMinus1 + 1`

Диапазон: `1 .. 65536`.

`props` присутствует только если `(ctrl & 0x40) != 0` (т.е. режим `M` = 2 или 3).

### Поле props (LZMA lc/lp/pb)

`props` — один байт, который кодирует параметры LZMA:

* `lc` (0..8)
* `lp` (0..4)
* `pb` (0..4)

Декодирование:

```
lc = props % 9
props /= 9
pb = props / 5
lp = props % 5
```

Для LZMA2 действует дополнительное ограничение: **lc + lp <= 4**.

### Payload

Сразу после заголовка идёт `packSize` байт **сырого LZMA1-потока**.

Важно:

* Это **не LZMA-Alone** (там есть отдельные поля свойств/размера).
* Это **сырой LZMA range-coded** поток, который декодируется ровно в `unpackSize` байт.
* Сам LZMA range coder начинается с байта `00` (проверка/инициализация range decoder). В вашем декодере это явно проверяется: если первый байт LZMA payload не `00`, поток считается повреждённым.

---

## 3) Размер словаря (dictionary size)

Raw LZMA2-поток **не хранит** dictionary size. Его должен задать внешний контейнер или API.

### Вариант 1: задавать напрямую

В вашей реализации это путь:

* `Lzma2Dec.Construct(ref p, dicSize)`

### Вариант 2: брать из «property byte» фильтра LZMA2 (например, в `.xz`)

В `.xz` у фильтра LZMA2 есть 1 байт свойств, кодирующий dictionary size. Он **не совпадает** с `props` (lc/lp/pb) внутри LZMA-чанка.

Формула (как в вашей `DicSizeFromProp`):

```
if prop == 40: dicSize = 0xFFFF_FFFF
else:          dicSize = (2 | (prop & 1)) << (prop / 2 + 11)
```

Допустимые значения: `prop <= 40`.

---

## 4) Мини-пример (как в тестах)

Тест `UpstreamLzmaSdk.WrapLzmaAlonePayloadIntoLzma2(...)` делает следующее:

1) Берёт LZMA-Alone байты (5 байт props + 8 байт unpackSize + LZMA payload)
2) Выбрасывает «обёртку» LZMA-Alone (5+8 байт)
3) Собирает **один** LZMA2 LZMA-чанк:

* `control = E0 | ((unpackSize-1) >> 16)`
  * `E0` означает: reset dictionary + reset state + в заголовке присутствует `props` (lc/lp/pb)
* далее `unpackSize-1` (2 байта)
* далее `packSize-1` (2 байта)
* далее `props = lzmaAlone[0]` (первый байт props LZMA-Alone)
* далее сам LZMA payload
* в конце `00`

Такой поток декодер должен распаковать в точный оригинал.
