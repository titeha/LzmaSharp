# План реализации энкодера LZMA2 (MVP → оптимизация)

Цель: получить **корректный LZMA2‑энкодер**, который пишет поток, который 7‑Zip/xz и наш декодер читают без ошибок.

## 0) Почему нельзя «просто один большой chunk»

В LZMA2 есть два жестких ограничения:

- `UnpackSize` для LZMA‑чанка: до ~2 MiB.
- `PackSize` для LZMA‑чанка: до 65536 байт (16‑битное поле `packSize-1`).

Если сжимать 2 MiB «плохих» данных, `PackSize` может получиться намного больше 64 KiB — и такой чанк **нельзя записать**.

Отсюда следует: энкодеру нужен механизм **нарезки и/или fallback на uncompressed**.

## 1) MVP-стратегия (самая простая, но рабочая)

### Идея

- Режем вход на куски по **64 KiB**.
- Для каждого куска пытаемся сделать LZMA‑чанк.
- Если результат `packSize > 65536` (или `packSize >= unpackSize`) — пишем **copy‑чанк** (uncompressed) вместо LZMA.

Это даст корректный поток и позволит легко распараллелить по чанкам.

### Control байты для MVP

Для простоты можно:

- для каждого LZMA‑чанка писать `control = 0xE0 | ((unpackSize-1) >> 16)` (это «reset dic + reset state + new props»),
- всегда писать `props` байт,
- после последнего чанка писать `0x00`.

Да, это убивает «сольность» между чанками (если всегда сбрасывать словарь). В MVP можно так сделать (и это хорошо параллелится). Потом добавим режим без сбросов.

## 2) Режим «нормальный» (правильный LZMA2)

После MVP добавляем:

- Сохранение словаря между чанками (control 0x80..),
- Сброс только когда нужно (например, при смене props или начале нового блока/файла),
- Возможность писать большие `unpackSize` чанки (до 2 MiB), но **флашить** при достижении лимита `packSize`.

Это фактически порт логики `Lzma2Enc.c` (из LZMA SDK).

## 3) Тесты для энкодера

Минимальный набор:

1. **Roundtrip**: `data -> EncodeLzma2 -> DecodeLzma2` даёт исходник.
2. **Cross-check**:
   - наш `Encode` + upstream `Decode`,
   - upstream `Encode` + наш `Decode`.
3. **Edge cases**:
   - пустой ввод,
   - 1 байт,
   - 64 KiB ровно,
   - 64 KiB + 1,
   - 2 MiB - 1,
   - «плохие» данные (случайные),
   - «хорошие» данные (много нулей/повторы).
4. **Стабильность**: encode должен быть детерминированным (при фикс. параметрах).

## 4) Куда параллелить

Самая понятная параллельность:

- **по независимым блокам** (reset dictionary на границах блоков) → почти линейный speedup на многопотоке.

Опционально:

- «solid mode» (без ресетов) — лучше сжатие, но хуже параллельность.

