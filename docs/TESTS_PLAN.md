# План тестов: что добавить дальше

Сейчас тесты покрывают два базовых сценария:

* COPY-чанк (несжатые данные)
* 1 LZMA-чанк, созданный из LZMA-Alone payload

Это хороший «дымовой» набор, но он почти не гарантирует, что код переживёт реальные файлы.
Ниже — список тестов, которые обычно первыми находят регрессы и тонкие баги.

## 1) Генеративные тесты (property-based / random)

Цель: получить много разных входов, но **без хранения бинарных golden-файлов**.

### 1.1 Roundtrip: Upstream Encoder → наш Decoder

Идея:

1) берём `byte[] original` разных размеров,
2) кодируем upstream LZMA (LZMA-Alone),
3) упаковываем в LZMA2-чанк,
4) декодируем нашим LZMA2,
5) сравниваем с `original`.

Варианты данных:

* случайные байты (но небольшие размеры, чтобы `packSize` не превысил 65536),
* сильно сжимаемые (нули, повторяющиеся паттерны) — можно тестировать и большие `unpackSize` вплоть до 2 MiB.

### 1.2 Разные `DictionarySize`

* закодировать с dic=64 KiB / 256 KiB / 1 MiB
* декодировать с тем же размером
* и отдельный тест: декодировать с **меньшим**, ожидая ошибку/повреждение (в зависимости от того, как именно вы хотите трактовать).

## 2) Streaming-тесты

Цель: убедиться, что `Parse` + `DecodeToDic` корректно переживают вход по кускам.

Идеи:

* делить вход на сегменты 1…N байт (например, псевдослучайно) и декодировать «как по сети».
* обязательно тестировать разрывы:
  - ровно посреди заголовка,
  - ровно на границе `Prop`,
  - ровно внутри payload-а.

## 3) Негативные тесты (ошибочные входы)

Цель: декодер должен возвращать `ERROR_DATA` / `NeedMoreInput` и **никогда** не зависать и не выходить за границы.

* `Control == 0x80` первым чанком (без инициализации словаря) → `ERROR_DATA`.
* LZMA-чанк с неправильным первым байтом payload-а (не 0x00) → `ERROR_DATA`.
* `Prop` такой, что `lc+lp > 4` → `ERROR_DATA`.
* обрезанный поток (не хватает байт заголовка / payload-а) → `NeedMoreInput`.

## 4) Граничные значения

* COPY `UnpackSize = 1` и `65536`.
* LZMA `UnpackSize = 1`, `2 MiB`.
* `PackSize = 1`, `65536` (сложнее получить честно, но можно руками сконструировать минимальные payload-ы и ожидать ошибку).

## 5) Cross-check с эталоном

Идеальный вариант: 

* иметь «второй» независимый декодер LZMA2 (например, C-референс из SDK, запущенный через P/Invoke) и сравнивать результаты.

Если пока это лишнее, оставляем как «в будущем».

## 6) Фаззинг (по желанию)

Минимальный фаззинг без инфраструктуры:

* генерировать `byte[]` случайной длины (например 0..128 KB)
* вызывать декодер
* проверять, что он **не падает исключениями**, а возвращает код ошибки.

Важно: фаззинг лучше запускать отдельно от юнит-тестов (например, как `dotnet run`-утилиту или отдельный test category), чтобы CI не стал нестабильным.
