# Как работает текущий декодер LZMA2 (по коду)

Этот документ — «карту местности» для того, что у нас уже есть: как читается поток LZMA2, где именно дергается LZMA(1)‑декодер, что означают поля `PackSize/UnpackSize`, почему там появляется `TempBuf[0] == 0` и т.д.

## 1) Слои

В текущей реализации есть два слоя:

1. **LZMA2** (контейнер из чанков): парсит *упаковку* на куски («compressed chunk» и «uncompressed/copy chunk»), управляет сбросами словаря/состояния, и для сжатых чанков отдаёт байты внутрь LZMA‑декодера.
2. **LZMA(1)** (range coder + LZ77): декодирует собственно LZMA‑поток в словарь.

В коде это обычно выглядит так:

- `CLzma2Dec` — машина состояний LZMA2.
- `CLzmaDec` — LZMA(1) декодер.
- `Lzma2Dec_DecodeToDic(...)` — главный цикл, который читает вход, пишет в словарь и переключает состояния.
- `LzmaDec_DecodeToDic(...)` — «ядро» LZMA‑декодера, которое реально восстанавливает байты.

## 2) Что такое словарь

Оба алгоритма пишут выход не в «отдельный буфер», а в **словари/окна** (sliding window). У `LZMA2` есть общий словарь (dictionary), куда пишутся и «copy‑чанки», и результат LZMA‑декодирования.

Из него потом либо:

- копируем данные в выходной буфер (`DecodeToBuf`), либо
- используем словарь как историю для следующих матчей.

## 3) Машина состояний LZMA2 (`CLzma2Dec`)

### Ключевые поля

- `State` — на каком шаге парсинга чанка мы сейчас находимся (читаем control, читаем размеры, читаем props, читаем данные).
- `Control` — управляющий байт LZMA2‑чанка.
- `UnpackSize` — сколько байт *должны распаковать* из текущего чанка (для copy‑чанка это просто длина копирования).
- `PackSize` — сколько байт *упакованных* данных надо прочитать для LZMA‑чанка.
- `NeedInitDic` — нужно ли «инициализировать словарь» (по сути сбросить позицию/историю, зависит от control).
- `NeedInitState` — нужно ли сбросить внутреннее состояние LZMA (range coder + вероятности), зависит от control.
- `TempBuf` + `TempBufSize` — маленький буфер для дозагрузки заголовка чанка/props, когда вход пришёл не целиком.

### Порядок чтения чанка

LZMA2 поток — это цепочка чанков:

1. `Control` (1 байт)
2. В зависимости от типа:
   - **Copy/Uncompressed chunk**: `unpackSize` в 2 байтах (big‑endian), потом `unpackSize` байт данных, которые прямо копируются в словарь.
   - **LZMA chunk**: `unpackSize` (3 байта «21‑битный размер»), `packSize` (2 байта), затем **опционально** 1 байт `props` (если в control стоит соответствующий флаг), затем `packSize` байт LZMA‑данных.

В коде это реализовано как switch по `State`:

- `Control` → `Unpack0` → `Unpack1` → (если LZMA) `Pack0` → `Pack1` → (если есть props) `Prop` → `Data`.

### Почему был `TempBuf[0] == 0`

Это уже не LZMA2‑заголовок, а **внутренний заголовок LZMA‑потока, который упакован внутри LZMA2‑чанка**.

В LZMA2 для LZMA‑чанка есть «мини‑заголовок» для LZMA‑декодера: туда кладутся ограничения на `lc/lp/pb`, маркеры сброса, и т.п. В ряде реализаций есть требование, что первый байт этого мини‑заголовка равен `0` (как часть соглашения/проверки). Мы как раз ловили баг, где проверка/чтение были смещены.

## 4) Где уменьшается `PackSize`

`PackSize` уменьшается в момент, когда мы реально «съедаем» `src` байты, относящиеся к текущему LZMA‑чанку.

Типичная схема внутри `DecodeToDic`:

- Пока состояние `Data`:
  - Если это copy‑чанк: копируем `UnpackSize` байт и уменьшаем `UnpackSize`.
  - Если это LZMA‑чанк:
    - Передаём `PackSize` байт (или часть) в `LzmaDec_DecodeToDic`.
    - Уменьшаем `PackSize` на количество реально использованных входных байт.

Именно поэтому в отладке «если `PackSize != 0` — идём дальше»: это означает, что декодеру ещё нужны входные байты для текущего LZMA‑чанка.

## 5) Маркер конца потока

По спецификации LZMA2 (в том числе в xz/liblzma) **маркер конца потока — байт `0x00`** как отдельный `control`.

Сейчас важно, чтобы декодер:

- воспринимал `control == 0x00` как конец,
- не пытался после него читать `Unpack0/Unpack1`.

Если такого поведения нет — тесты могут всё равно проходить, если у нас *известен outSize* и мы выходим по достижению размера. Но для полноценного «архиватора» нам нужен корректный end‑marker.

## 6) Как это дебажить дальше

Если опять появится падение на данных:

1. Логируем последовательность чанков: `control`, `unpackSize`, `packSize`, `props`.
2. На вход LZMA‑декодера логируем:
   - первые 16 байт LZMA‑данных,
   - `dicPos`, `processedPos`, `checkDicSize`.
3. При ошибках `ERROR_DATA` смотрим:
   - где именно вернулось (`DecodeToDic` LZMA2 или LZMA1),
   - какие инварианты нарушены (например, `len` в `DecodeReal3`).

