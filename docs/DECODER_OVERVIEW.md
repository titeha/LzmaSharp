# Как устроен декодер (порт из 7-Zip SDK)

В репозитории фактически лежит **прямой порт C-кода из 7-Zip / LZMA SDK** (Lzma2Dec.c + LzmaDec.c) на C#.

Это объясняет два важных момента:

* код выглядит «не по-C#-ному» (много `struct`, ручная работа с состояниями, минимум аллокаций),
* значительная часть логики — это **конечный автомат** (state machine), который по байтам читает заголовки чанков и затем либо копирует данные, либо запускает LZMA-декодер.

Ниже — краткая карта того, что где находится и что означает.

## Главные сущности

### `CLzma2Dec`

Состояние LZMA2-декодера (обёртка над LZMA1):

* `State` — где мы находимся в чтении заголовка/данных (Control → ... → Data → ...).
* `Control` — байт управления текущего чанка.
* `UnpackSize` — сколько байт надо выдать в выход (для текущего чанка).
* `PackSize` — сколько байт надо прочитать из входа (для текущего чанка, только для LZMA-чанков).
* `NeedInitDic` — «словарь ещё не инициализирован», т.е. первый LZMA-чанк обязан быть режима `0xE0..0xFF`.
* `TempBuf` / `TempBufSize` — буфер для частичного чтения заголовков, если вход пришёл не целиком.
* `Decoder` — вложенный `CLzmaDec` (сам LZMA1-двигатель).

### `CLzmaDec`

Состояние LZMA1-декодера:

* `Dic` — ссылка на выходной буфер (словарь).
* `DicPos` / `DicBufSize` — позиция и размер словаря.
* `Prop` — LZMA свойства `lc/lp/pb`.
* `Probs` — массив вероятностей range coder-а.
* `TempBuf` / `TempBufSize` — промежуточные байты для инициализации range coder-а.

## Что делает `Lzma2Dec.DecodeToDic`

Это основной метод «съесть кусок входа и распаковать в словарь». Очень полезно воспринимать его как цикл:

1) **Если мы не в `State.Data`** — значит мы читаем заголовок чанка (байт `Control`, потом размеры, потом, возможно, `Prop`).
   * На каждом шаге вычитывается нужное количество байт.
   * Как только заголовок собран целиком, `State` переходит в `Data`.

2) **Если чанк COPY (`Control` 0x01/0x02)** — просто копируем `UnpackSize` байт из входа в словарь.

3) **Если чанк LZMA (`Control` >= 0x80)** — запускаем LZMA-декодер:
   * по `Control` вычисляем, нужно ли сбросить словарь (`>= 0xE0`) и/или LZMA-состояние (`>= 0xA0`),
   * при необходимости читаем `Prop` (если `Control & 0x40 != 0`),
   * затем вызываем `LzmaDec.DecodeToDic`, но ограничиваем его:
     - максимумом выходных байт текущего чанка (`UnpackSize`),
     - максимумом входных байт текущего чанка (`PackSize`).

4) Когда `UnpackSize` (или `Rem`) для чанка становится 0 — чанк закончен, автомат возвращается в `State.Control` и ждёт следующий `Control`.

5) Когда встречается `Control == 0x00` — поток закончен (`Finished`).

## Про `Parse` и `TempBuf`

`Parse(...)` нужен для сценария, когда входной поток может приходить по кускам (streaming):

* он «докачивает» заголовок чанка в `TempBuf`,
* обновляет `State`, `PackSize`, `UnpackSize`,
* и возвращает `NeedMoreInput`, если заголовок/данные ещё не полностью получены.

Важно: `Parse` содержит быструю проверку валидности LZMA payload-а: **первый байт range coder-а должен быть `0x00`**. Если он не ноль — это почти всегда повреждение данных.

## Почему внутри так много проверок `len` / `kMatchSpecLen_Error_Data`

Внутри `LzmaDec` есть несколько реализаций «горячего» цикла декодирования (`DecodeReal...`).

`len` — это длина матча, который алгоритм LZMA пытается воспроизвести из словаря (LZ77-ссылка назад). Если из битового потока получается невозможная длина (например, больше допустимого лимита), декодер возвращает `ERROR_DATA`.

Если нужно отлаживать подобные проблемы, почти всегда полезно смотреть на:

* значения `Control`, `UnpackSize`, `PackSize`,
* первые 8–16 байт payload-а чанка,
* в LZMA-части: `range`, `code`, `DicPos`, `processedPos`.

## Мини-карта: где что менять

* **Если проблема в заголовке чанка / контрольных байтах** — смотрим `Lzma2Dec.UpdateState` + ветку `State != Data` в `DecodeToDic`.
* **Если проблема в распаковке LZMA payload-а** — смотрим `LzmaDec.DecodeToDic` и `DecodeReal...`.
* **Если падают COPY-чанки** — смотрим ветку `Control <= 2` в `DecodeToDic`.

