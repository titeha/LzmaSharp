# Формат LZMA-Alone (`.lzma`)

В тестах вы используете «LZMA-Alone» как удобный способ получить валидный LZMA1-поток из SDK, а потом упаковать его в LZMA2-чанк.

LZMA-Alone — это простой «обёрточный» формат, который хранит:

1) **Свойства LZMA** (5 байт)
2) **Размер распакованных данных** (8 байт)
3) **Сырые LZMA range-coded данные** (переменной длины)

## 1) 5 байт свойств

Структура:

```
+--------+------------------------------+
| props  | dictionarySize (4 bytes, LE) |
+--------+------------------------------+
```

* `props` — 1 байт, кодирующий `lc/lp/pb` (см. описание в документе про LZMA2).
* `dictionarySize` — 32-битное значение **little-endian**, размер словаря в байтах.

## 2) 8 байт unpacked size

Далее идут 8 байт **little-endian** — заявленный размер распакованных данных.

Замечание: иногда (например в потоковых сценариях) значение может быть `0xFFFF_FFFF_FFFF_FFFF`, что означает «размер неизвестен заранее». В ваших тестах размер известен.

## 3) LZMA payload

После заголовка идёт LZMA1 range-coded поток.

* Range coder внутри LZMA начинается с байта `00`.
* В LZMA-Alone поток часто заканчивается EOS-маркером, но при наличии известного unpacked size декодер может остановиться по нему.

## Как это используется в ваших тестах

`UpstreamLzmaSdk.WrapLzmaAlonePayloadIntoLzma2(...)`:

* берёт `lzmaAlone[0]` как `props` для LZMA2 (lc/lp/pb)
* отрезает `5 + 8` байт заголовка LZMA-Alone
* оставшиеся байты считает «сырым» LZMA payload и кладёт в LZMA2 LZMA-чанк
